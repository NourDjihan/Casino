"
""LOAD FAST""

""Reset Work""
MooseModel resetRoot.
MooseModel resetMeta.

""Generate BlApp""
mseFile := StandardFileStream fileNamed: 'D:\Users\benoit.verhaeghe\Documents\PFE\GeneralXmlui.mse' .
mooseModel := MooseModel importFromMSEStream: mseFile .
mooseModel rootFolder: 'D:\Users\benoit.verhaeghe\Documents\PFE\'.

""Generate Bl Model""
model := MooseModel new name: 'Showroom'; yourself.
BLMooseModelCreatorAngular runOn: model fromSourceModel: mooseModel and:  'D:\Users\benoit.verhaeghe\Documents\PFE\Source\BLCoreIncubatorGwt\src\fr\bl\application.module.xml'.

BLGlobalView new openViewForModel: model.

""Add Model to moose panel""
MooseModel root add: model.

model := BLModelExample generateModelWithTwoPhasesAndThreePageMetierAnd1Widget.
BLModelExporterAngular export: model.
"
Class {
	#name : #BLWebModelJava,
	#superclass : #BLWebModel,
	#instVars : [
		'pageMetierGroup',
		'phaseGroup',
		'widgetGroup',
		'actionAppelGroup',
		'listOfService',
		'xml',
		'modelWidgetCache',
		'xmlUiLink',
		'xmlUiWidgetLink',
		'listOfServiceAction'
	],
	#category : 'BL-Model-Importer-Java'
}

{ #category : #'as yet unclassified' }
BLWebModelJava class >> webRoot [
	"I represent the root of URL"
	^ 'http://ap15mogbl:8080/Web_coreincubator/coreincubator/skins/e-sedit/'
]

{ #category : #adding }
BLWebModelJava >> addLinkBetweenServiceAndAttribute [
	self listOfServiceAction do: [ :serviceAction | 
		| classContainer |
		classContainer := serviceAction source incomingInvocations collect: [ :invocation | invocation from belongsTo ].
		(self model allBLActionsAttribute select: [:action | classContainer includes: action source  ]) do: [ :action | action addBehavior: serviceAction  ] ]
]

{ #category : #adding }
BLWebModelJava >> addLinkBetweenWidgets [
	| responsabilityHandlerForUsages |
	responsabilityHandlerForUsages := BLLinkWidgetResponsabilitiesReceiverHandler new.
	self listOfWidgetContainer
		do: [ :widgetContainer | 
			(widgetContainer isKindOf: OrderedCollection)
				ifFalse: [ | usages |
					usages := widgetContainer affectedActions allUsages.
					
					responsabilityHandlerForUsages handleAddLinkedFromVariable: usages to: widgetContainer withXmlui: xmlUiWidgetLink andImporter: self.
					]
				ifTrue: [ widgetContainer
						do: [ :widget | 
							| containerInvocation |
							containerInvocation := widget blWidget constructor container.
							[ containerInvocation isNotNil ]
								whileTrue: [ self listOfWidgetContainer
										at: containerInvocation receiver
										ifPresent: [ :found | 
											found blWidget addWidget: widget blWidget.
											containerInvocation := nil ]
										ifAbsent: [ containerInvocation := containerInvocation container ] ] ] ] ]
]

{ #category : #adding }
BLWebModelJava >> addLinkForAbstractTabPhase [
	self linkForAbstractTabPhase do: [ :assoc | (self getPhaseFromClass: assoc key) do: [ :phase | (self getPageMetierFromClass: assoc value) do: [ :pageMetier | phase pageMetiers add: pageMetier ] ] ]
]

{ #category : #adding }
BLWebModelJava >> addLinkPageMetierToPageMetier [
	self linkPageMetierToPageMetier
		do: [ :assoc | self addTo: assoc key from: assoc value in: #widgets ]
]

{ #category : #adding }
BLWebModelJava >> addLinkPhaseToPageMetier [
	(self computeAllConstructorsLink collect: [ :a | (self getPhaseFromClass: a key) -> (self getPageMetierFromClass: a value) ] thenSelect: [ :a | a key isNotNil and: [ a value isNotNil ] ])
		do: [ :assoc | self addTo: assoc key from: assoc value in: #pageMetiers	"assoc key do: [ :from | from metiers add: assoc value ]" ]
]

{ #category : #adding }
BLWebModelJava >> addLinkXmlUi [
	xmlUiLink := self linkXmlUiPhaseAndPageMetier asDictionary reverse.
	xmlUiWidgetLink := self linkXmlUiWidget asDictionary reverse.
]

{ #category : #adding }
BLWebModelJava >> addLinkXmlUiWidget [
	xmlUiWidgetLink := self linkXmlUiWidget asDictionary reverse
]

{ #category : #adding }
BLWebModelJava >> addLinkedFromVariable: variables to: widgetContainer [
	(variables collect: [ :var | self listOfWidgetContainer at: var ifAbsent: [  ] ] thenSelect: #isNotNil)
		ifNotEmpty: [ :founds | 
			founds do: [ :found | found blWidget addWidget: widgetContainer blWidget ].
			^ true ].
	^ false
]

{ #category : #adding }
BLWebModelJava >> addListsToModel [
	model
		addAll: self listOfPhases;
		addAll: self listOfPageMetier;
		addAll: self listOfWidget;
		addAll: self listOfService;
		addAll: self listOfServiceAction;
		addAll: self listOfActionAppel;
		addAll: (self listOfWidget flatCollect: #attributes);
		addAll: ((self listOfPhases flatCollect: #pageMetiers) select: [ :metier | metier name = 'autoGenerated' ])
	"Adding autoGeneratedPageMetier"
]

{ #category : #adding }
BLWebModelJava >> addOnClickAttribute [
	(((self sourceModel allClasses select: [ :c | 'ClickHandler' match: c name ]) at: 1)
		subclassHierarchy select: [ :class | self isElementFromApplication: class ])
		do: [ :class | 
			(class allUsages collect: #receiver)
				do: [ :receiver | 
					self listOfWidgetContainer
						at: receiver
						ifPresent: [ :found | 
							found blWidget createAttributeFrom: class
								 ]
						ifAbsent: [  ] ] ]
]

{ #category : #adding }
BLWebModelJava >> addPPPToWidget [
	(self listOfWidget select: [ :a | a widgetOwner isNil ])
		do: [ :widget | 
			| founds |
			founds := self widgetOwnerCase1: widget source from.
			founds ifNotNil: [ founds do: [ :found | found addWidget: widget ] ] ]
]

{ #category : #private }
BLWebModelJava >> addTo: aSourcedCollection from: anotherSourcedCollection in: theSelectorOfTheCollection [
	aSourcedCollection
		do: [ :source1 | 
			anotherSourcedCollection
				do: [ :source2 | (theSelectorOfTheCollection value: source1 ) add: source2 ] ]
]

{ #category : #adding }
BLWebModelJava >> addWidgetAttributes [

			(self listOfWidget select: [ :widget | widget variable isNotNil ])
				do: [ :widget | 
					widget variable receivingInvocations
						do: [ :invoc | widget createAttributeFrom: invoc ] ]
]

{ #category : #adding }
BLWebModelJava >> addWidgetDefaultAttributes [
	self listOfWidget do: #addDefaultAttribute
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> appNamespace [
	^ 'fr::bl::client::grh::*'
]

{ #category : #accessing }
BLWebModelJava >> applicationSource [
	"name of the directory with the GWT application"
	^  'BLCoreIncubatorGwt'
]

{ #category : #api }
BLWebModelJava >> codeMetierImporter [
	^ FASTJavaImporterVisitor 
]

{ #category : #adding }
BLWebModelJava >> computeAllConstructorsLink [
	^ (self sourceModel constructors
		collect: [ :method | 
			| got |
			got := (method queryAll: #in) atScope: FAMIXClass.
			got
				ifNotEmpty: [ got collect: [ :p | Association new key: p value: method parentType ] ] ])
		flatten
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> createPageMetierInModel: aPageMetier [
	^ BLPageMetier new
		name: aPageMetier mooseName;
		sourceAnchor: aPageMetier sourceAnchor;
		source: aPageMetier;
		computeTitle 
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> createPhaseInModel: xmlElement [
	| blPhase |
	blPhase := BLPhase new
		realClassName:
			((xmlElement attributeAt: #className)
				ifNotNil: [ :a | (a replaceAllRegex: '\.' with: '::') replaceAllRegex: ' ' with: '' ]
				ifNil: [ (xmlElement parent attributeAt: 'name') = self moduleHomeName
						ifTrue:
							[ ((self sourceModel allModelClasses select: [ :e | (e superInheritances collect: [ :a | a to name ]) includes: 'HomePhaseController' ]) at: 1) mooseName ]
						ifFalse: [ ^ nil ] ]);
		codePhase: (xmlElement attributeAt: #codePhase);
		codeValue: (xmlElement attributeAt: #codeValue);
		name: (xmlElement attributeAt: #codeValue).
	blPhase
		source: (self getClassNamed: blPhase realClassName);
		computeTitle;
		computeSubtitle.
	^ blPhase
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> createServiceFromClass: aServiceClass [
	^ BLService newFor: aServiceClass
		
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generateBLActionAppel [
	actionAppelGroup := self linkFromWidgetActionAppel
		collect: [ :el | 
			| action |
			action := BLActionAppel new.
			el key addAction: action.
			el value ifNil: [  ] ifNotNil: [ action actionAppelOwner: el value  ].
			action ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generatePageMetier [
	(sourceModel allModelClasses
		select: [ :e | (e superclassHierarchy contains: [ :a | a name = 'IPageMetier' ]) and: [ ('*XMLUi' match: e name) not ] ])
		do: [ :aPhase | self listOfPageMetier add: (self createPageMetierInModel: aPhase) ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generatePhase [
	xml
		nodesDo: [ :aXmlNode | 
			(aXmlNode isElement and: [ aXmlNode name localName = 'phase' ])
				ifTrue: [ self listOfPhases add: (self createPhaseInModel: aXmlNode) ] ].
	self listOfPhases: (self listOfPhases select: #isNotNil) 
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generateService [
	| interfaceService |
	interfaceService := self sourceModel allTypes
		select:
			[ :e | (e superclassHierarchy contains: [ :a | a name = 'RemoteService' ]) and: e isInterface ].
	interfaceService
		addAll:
			((interfaceService flatCollect: [ :class | class classes flatCollect: #attributes ])
				collect: #declaredType).
	interfaceService
		do: [ :aServiceClass | self listOfService add: (self createServiceFromClass: aServiceClass) ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generateServiceAction [
	self listOfServiceAction
		addAll:
			((self listOfService
				collect: [ :service | 
					service addAllActions: 
					(self getListOfServiceActionForServiceClass: service source)]) collect: #serviceActions) flattened
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generateWidget [
	self listOfWidgetContainer at: #noVar put: OrderedCollection new.
	self widgetInstance
		do: [ :widget | 
			widget affectedActions
				ifNotNil: [ :key | self listOfWidgetContainer at: widget variable put: widget ]
				ifNil: [ (self listOfWidgetContainer at: #noVar) add: widget ] ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getAsyncClassFrom: aServiceClass. [
	^ (aServiceClass types asOrderedCollection 
		at: 1	ifAbsent: [ ^ {} ]) attributes
				collect: #declaredType
				thenSelect: [ :class | aServiceClass name , '*' match: class name ] 
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getClassNamed: aClassName [
	^ (self sourceModel allModelClasses select: [ :a | a mooseName = aClassName ]) at: 1
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getFromSource: listofSourcedElement forClass: aClass [
	^ (xmlUiLink at: aClass ifAbsent: [ ^ (listofSourcedElement select: [ :a | a source = aClass ]) ifEmpty: [ ^ nil ] ifNotEmpty: [ :a | {(a at: 1)} ] ])
		collect: [ :class | (listofSourcedElement select: [ :a | a source = class ]) ifEmpty: [ ^ nil ] ifNotEmpty: [ :a | a at: 1 ] ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getListOfServiceActionForServiceClass: aServiceClass [
	"Looking for class with `aServiceClass name ', Async'` 
	
	Currently disable because we don't know why we should want NOT async method... and all the method are the same.
	So we can say that all the non async method are also all the async method (with an arg less)
	Please consider this method return all the async method"

	| listOfSubAsyncClass |
	listOfSubAsyncClass := {} "self getAsyncClassFrom: aServiceClass".
	^ (listOfSubAsyncClass flatCollect: #methods) , aServiceClass methods reject: [ :method | method sourceAnchor sourceText isEmpty "reject method from src/target/... In source"]
		thenCollect: [ :method | BLServiceAction newFor: method ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getPageMetierFromClass: aClass [
	^ self getFromSource: self listOfPageMetier forClass: aClass
]

{ #category : #private }
BLWebModelJava >> getPhaseCallInvocations [
	^ (((self sourceModel allClasses
		select:
			[ :a | '*ConstantsPhase' match: a mooseName ])
		at: 1) methods collect: #incomingInvocations) flatten
]

{ #category : #private }
BLWebModelJava >> getPhaseClassFrom: realClassName [
	realClassName ifNil: [ ^self ].
	^ (self sourceModel allClasses select: [ :e | realClassName = e mooseName ]) at: 1
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getPhaseFromClass: aClass [
	^ self getFromSource: self listOfPhases  forClass: aClass
]

{ #category : #private }
BLWebModelJava >> getPhaseNamed: aCodePhase [
	^ (self listOfPhases select: [ :e | e codePhase = aCodePhase ])
		ifEmpty: [ Transcript crLog: 'error for ' , aCodePhase.
			^ nil ]
		ifNotEmpty: [ :a | a at: 1 ]
]

{ #category : #accessing }
BLWebModelJava >> gwtWidgetNamespace [
	^ 'com::google::gwt::user::client::ui*'
]

{ #category : #api }
BLWebModelJava >> import [
	self generatePhase.
	self generatePageMetier.
	self addLinkXmlUi.
	self addLinkXmlUiWidget.
	self addLinkForAbstractTabPhase.
	self addLinkPhaseToPageMetier.
	self addLinkPageMetierToPageMetier.
	self generateWidget.
	"keep this order for the widget adding. The second one depends on the first one.... Maybe i should create one method 'generate widgetlink'"
	self addLinkBetweenWidgets.
	self addPPPToWidget.
	self generateBLActionAppel.
	self generateService.
	self generateServiceAction.
	"this last two should stay at the end"
	self addWidgetAttributes.
	self addOnClickAttribute.
	self addWidgetDefaultAttributes.

	self addListsToModel.
	self addLinkBetweenServiceAndAttribute.
]

{ #category : #initialization }
BLWebModelJava >> initialize [
	super initialize.
	pageMetierGroup := OrderedCollection new.
	phaseGroup := OrderedCollection new.
	widgetGroup := Dictionary new.
	listOfService := OrderedCollection new.
	listOfServiceAction := OrderedCollection new.
	actionAppelGroup := OrderedCollection new.
]

{ #category : #accessing }
BLWebModelJava >> isElementFromApplication: e [
	^ e sourceAnchor isNotNil and: [('*' , self applicationSource , '*' match: e sourceAnchor fileName)]
]

{ #category : #accessing }
BLWebModelJava >> isWidgetFromApplication: e [
	^ (self isElementFromApplication: e)
		and: [ (({self listOfPhases.
			self listOfPageMetier} flatten collect: #source) includes: e) not ]
]

{ #category : #private }
BLWebModelJava >> linkForAbstractTabPhase [
	^ (self modelPhases 
		select: [ :a | 
			(a withSuperclassHierarchy collect: #name)
				anySatisfy: [ :name | 'AbstractTabPhaseController' = name ] ]
		thenCollect: [ :class | 
			class withSuperclassHierarchy
				collect: [ :c | 
					(c outgoingInvocations
						reject: [ :invoc | invoc receiver ifNotNil: [ :el | el name = #super ] ifNil: [ false ] ]
						thenCollect: [ :invoc | invoc candidates at: 1 ])
						select: [ :e | e isConstructor and: [ self modelPageMetier includes: e parentType ] ]
						thenCollect: [ :e | class -> e parentType ] ] ]) flattened
]

{ #category : #private }
BLWebModelJava >> linkFromWidgetActionAppel [
	" Miss 7
	4 for dispatch -> ignore
	3 for carousel"
	^ self getPhaseCallInvocations
		collect: [ :el | 
			| link |
			link := self linkFromWidgetActionAppelCase1: el.
			link ifNil: [ link := self linkFromWidgetActionAppelCase2: el ].
			link ]
		thenSelect: #isNotNil
]

{ #category : #private }
BLWebModelJava >> linkFromWidgetActionAppelCase1: anInvocation [
	"Return the found association
	case 1 and 4
	new Widget ( new blabla ( new bleble ( CP)))"

	| found elContainer |
	found := nil.
	elContainer := anInvocation container.
	elContainer ifNil: [ ^ nil ].
	" case 1 "
	found := self searchWidgetFromConstructorInvocation: elContainer.
	found
		ifNotNil: [ ^ Association new key: found value: (self searchCalledPhaseFromInvocation: anInvocation) ]
		ifNil: [ ^ self linkFromWidgetActionAppelCase1: elContainer ]
]

{ #category : #private }
BLWebModelJava >> linkFromWidgetActionAppelCase2: anInvocation [
	"Return the found association
	case 2
	var i = new Widget ()
	i.addHandler..(BlBl)"
 
	anInvocation from parentType isHandlerClass
		ifFalse: [ ^ nil ].
	self listOfWidgetContainer
		at:
			((anInvocation from parentType container outgoingInvocations
				select: [ :invoc | invoc sourceAnchor isNotNil and: [ 
					invoc sourceAnchor startPos < anInvocation sourceAnchor startPos
						and: [ invoc sourceAnchor endPos > anInvocation sourceAnchor endPos ] ] ]) at: 1 ifAbsent: [ ^ nil ])
				receiver
		ifPresent: [ :widgetContainer | 
			^ Association new
				key: widgetContainer blWidget
				value: (self searchCalledPhaseFromInvocation: anInvocation) ]
		ifAbsent: [ ^ nil ]
]

{ #category : #private }
BLWebModelJava >> linkPageMetierToPageMetier [
	^ ((self listOfPageMetier collect: #source), xmlUiLink keys 
		flatCollect: [ :pageMetier | 
			(pageMetier outgoingInvocations
				reject: [ :invoc | 	invoc  signature matchesRegex: '.*this\(.*|.*super\(.*'   ]
				thenCollect: [ :invoc |  invoc candidates at: 1 ])
				select: [ :e | (e isConstructor and: [ self modelPageMetier includes: e parentType ]) ]
				thenCollect: [ :e | (self getPageMetierFromClass: (pageMetier)) -> (self getPageMetierFromClass: (e parentType)) ] ] )select: [ :assoc | assoc key isNotNil ]
]

{ #category : #private }
BLWebModelJava >> linkXmlUiPhaseAndPageMetier [
	^ {self modelPhases  , self modelPageMetier} flatten
		select: [ :a | '*XMLUi' match: a superclass mooseName ]
		thenCollect: [ :a | Association new key: a  value: a superclass]
]

{ #category : #adding }
BLWebModelJava >> linkXmlUiWidget [
	^ {self modelWidget} flatten
		select: [ :a | '*XMLUi' match: a superclass mooseName ]
		thenCollect: [ :a | Association new key: a  value: a superclass]
]

{ #category : #accessing }
BLWebModelJava >> listOfActionAppel [
	^ actionAppelGroup 
]

{ #category : #accessing }
BLWebModelJava >> listOfPageMetier [
	^ pageMetierGroup
]

{ #category : #accessing }
BLWebModelJava >> listOfPhases [
	^ phaseGroup
]

{ #category : #accessing }
BLWebModelJava >> listOfPhases: anOrderedCollection [
	phaseGroup := anOrderedCollection
]

{ #category : #accessing }
BLWebModelJava >> listOfService [
	^ listOfService
]

{ #category : #accessing }
BLWebModelJava >> listOfService: anObject [
	listOfService := anObject
]

{ #category : #accessing }
BLWebModelJava >> listOfServiceAction [
	^ listOfServiceAction
]

{ #category : #accessing }
BLWebModelJava >> listOfServiceAction: anObject [
	listOfServiceAction := anObject
]

{ #category : #accessing }
BLWebModelJava >> listOfWidget [
	^ widgetGroup flattened collect: #blWidget
]

{ #category : #accessing }
BLWebModelJava >> listOfWidgetContainer [
	^ widgetGroup
]

{ #category : #accessing }
BLWebModelJava >> modelPageMetier [
	^ self listOfPageMetier collect: #source
]

{ #category : #private }
BLWebModelJava >> modelPhases [
	^ self listOfPhases collect: #source
]

{ #category : #accessing }
BLWebModelJava >> modelWidget [
	^ modelWidgetCache
		ifNil: [ modelWidgetCache := self sourceModel allClasses
				select: [ :e | 
					(e superclassHierarchy anySatisfy: [ :a | a name = 'Widget' ])
						and: [ (self widgetNamespace match: e container mooseName)  or: [ (self gwtWidgetNamespace match: e container mooseName )
								or: [ self isWidgetFromApplication: e ] ] ] ] ]
]

{ #category : #private }
BLWebModelJava >> modelWidgetInstances [
	^ self listOfWidget collect: #source
]

{ #category : #accessing }
BLWebModelJava >> moduleHomeName [
	^ 'BL_HOME_PHASE_MODULE'
]

{ #category : #api }
BLWebModelJava >> postImport [
	self model allBLActionsAttribute do: [ :actionAttribute | actionAttribute convertOldClass ]
]

{ #category : #api }
BLWebModelJava >> preImport [
	BLActionAttribute moulinetteStrategy: BLMoulinetteFASTStrategy new.
]

{ #category : #private }
BLWebModelJava >> searchAffectationForInvocationOrAnonymousClass: anInvocationOrAnonymousClass [
	"The mooseVariable if there is an affactation
	else nil
	
	1. We look for a local variable
	2. We look for a class variable 
		2.1 Because we don't have enought information with famix. We've supposed that the affectation is not to far from the access of the variable. So we've write 5 'space'. But it's not sure
	3. We look in declaration in the class
	"

	^ anInvocationOrAnonymousClass affectation
]

{ #category : #private }
BLWebModelJava >> searchCalledPhase: aSignature [
	^ (self getPhaseNamed: (aSignature replaceAllRegex: '\(\)' with: '')) ifNil: [^nil]
]

{ #category : #private }
BLWebModelJava >> searchCalledPhaseFromInvocation: invoc [
	^ self searchCalledPhase:  (invoc to at: 1) signature
]

{ #category : #private }
BLWebModelJava >> searchWidgetFromConstructorInvocation: anInvocation [
	^ (self listOfWidget select: [ :widget | widget constructor = anInvocation ]) at: 1 ifAbsent: [ ^nil ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetAnonymousSubclasses [
	^ ((self modelWidget flatCollect: [ :widget | widget subclassHierarchy ]) select: #isAnonymousClass) asOrderedCollection 
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetConstructorsInvocation [
	^ (self modelWidget
		collect: [ :widget | (widget methods select: [:method | method isConstructor or: [
							method signature includesSubstring: method belongsTo name] ] thenCollect: #incomingInvocations ) ])
		flattened
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetInstance [
	^ (self widgetConstructorsInvocation , self widgetAnonymousSubclasses
		reject: [ :invocationOrClass | 
			(self widgetNamespace match: invocationOrClass from mooseName)
				or: [ '*noname#super*' match: invocationOrClass asString ] ])
		collect: [ :invocation | 
			| blWidget |
			blWidget := BLWidgetContainer new.
			blWidget blWidget: (BLWidget newFor: invocation).
			blWidget affectedActions: (self searchAffectationForInvocationOrAnonymousClass: invocation).
			blWidget blWidget variable: blWidget variable.
			blWidget ]
]

{ #category : #accessing }
BLWebModelJava >> widgetNamespace [
	^ 'fr::bl::client::core::refui*'
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetOwnerCase1: invocation [
	| found |
	(invocation isNil or: [ invocation isNamespace ])
		ifTrue: [ ^ nil ].
	invocation isClass
		ifFalse: [ ^ self widgetOwnerCase1: invocation belongsTo ]
		ifTrue: [ found := self getPhaseFromClass: invocation.
			found
				ifNotNil: [ ^ found ]
				ifNil: [ found := self getPageMetierFromClass: invocation.
					found ifNotNil: [ ^ found ].
					invocation incomingReferences ifNotEmpty: [ :references | ^ self widgetOwnerCase1: (references at: 1) from belongsTo maxLevel: 15 level: 0 ] ] ].
	^ self widgetOwnerCase1: invocation belongsTo
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetOwnerCase1: invocation maxLevel: maxLevel level: level [
	| found |
	level = maxLevel
		ifTrue: [ ^ nil ].
	(invocation isNil or: [ invocation isNamespace ])
		ifTrue: [ ^ nil ].
	invocation isClass
		ifFalse: [ ^ self widgetOwnerCase1: invocation maxLevel: maxLevel level: level + 1 ]
		ifTrue: [ found := self getPhaseFromClass: invocation.
			found
				ifNotNil: [ ^ found ]
				ifNil: [ found := self getPageMetierFromClass: invocation.
					found ifNotNil: [ ^ found ].
					invocation incomingReferences ifNotEmpty: [ :references | ^ self widgetOwnerCase1: (references at: 1) from belongsTo maxLevel: maxLevel level: level + 1 ] ] ].
	^ self widgetOwnerCase1: invocation maxLevel: maxLevel level: level + 1 
]

{ #category : #accessing }
BLWebModelJava >> xml [
	^ xml
]

{ #category : #accessing }
BLWebModelJava >> xml: anObject [
	xml := anObject
]
