"
SmalltalkImage current garbageCollectMost .

""Generate BlApp""
mooseModel := MooseModel importFromMSEStream:  'D:\Users\benoit.verhaeghe\Documents\PFE\GeneralXmlui.mse' asFileReference readStream.
mooseModel rootFolder: 'D:\Users\benoit.verhaeghe\Documents\PFE\'.

""Generate Bl Model""
model := MooseModel new name: 'Showroom'; yourself.
BLMooseModelCreatorAngular runOn: model fromSourceModel: mooseModel and:  'D:\Users\benoit.verhaeghe\Documents\PFE\Source\BLCoreIncubatorGwt\src\fr\bl\application.module.xml'.

BLGlobalView new openViewForModel: model.

""Add Model to moose panel""
MooseModel root add: model.

model := BLModelExample generateModelWithTwoPhasesAndThreePageMetierAnd1Widget.
BLModelExporterAngular export: model.
"
Class {
	#name : #BLWebModelJava,
	#superclass : #BLWebModel,
	#instVars : [
		'xml',
		'xmlUiLink',
		'modelWidgetCache',
		'xmlUiWidgetLink'
	],
	#category : #'BL-Model-CoreWeb-Importer'
}

{ #category : #accessing }
BLWebModelJava class >> webRoot [
	"I represent the root of URL"
	^ 'http://ap15mogbl:8080/Web_coreincubator/coreincubator/skins/e-sedit/'
]

{ #category : #adding }
BLWebModelJava >> addLinkBetweenServiceAndAttribute [
	self model allBLServiceAction
		do: [ :serviceAction | 
			| classContainer |
			classContainer := serviceAction source incomingInvocations collect: [ :invocation | invocation from belongsTo ].
			(self model allBLActionsAttribute select: [ :action | classContainer includes: action source ])
				do: [ :action | action addBehavior: serviceAction ] ]
		displayingProgress: [ :serviceAction | 'for ' , serviceAction asString ]
		every: 1000
]

{ #category : #adding }
BLWebModelJava >> addLinkBetweenWidgets [
	| responsabilityHandlerForUsages |
	responsabilityHandlerForUsages := BLLinkWidgetResponsabilitiesReceiverHandler new.
	self model allBLWidgetExceptPage
		do: [ :widget | self addParentTo: widget withHandlerForUsages: responsabilityHandlerForUsages ]
		displayingProgress: [ :widget | 'compute ' , widget class name ]
		every: 1000
]

{ #category : #adding }
BLWebModelJava >> addLinkForAbstractTabPhase [
	self linkForAbstractTabPhase
		do: [ :assoc | 
			(self getPhaseFromClass: assoc key)
				do: [ :phase | (self getPageMetierFromClass: assoc value) do: [ :pageMetier | phase businessPage add: pageMetier ] ] ]
		displayingProgress: [ :assoc | 'compute ' , assoc name ]
		every: 1000
]

{ #category : #adding }
BLWebModelJava >> addLinkPageMetierToPageMetier [
	self linkPageMetierToPageMetier
		do: [ :assoc | self addTo: assoc key from: assoc value in: #widgets ]
]

{ #category : #adding }
BLWebModelJava >> addLinkPhaseToPageMetier [
	(self computeAllConstructorsLink collect: [ :a | (self getPhaseFromClass: a key) -> (self getPageMetierFromClass: a value) ] thenSelect: [ :a | a key isNotNil and: [ a value isNotNil ] ])
		do: [ :assoc | self addTo: assoc key from: assoc value in: #businessPage	"assoc key do: [ :from | from metiers add: assoc value ]" ]
]

{ #category : #adding }
BLWebModelJava >> addLinkXmlUi [
	xmlUiLink := self linkXmlUiPhaseAndPageMetier asDictionary reverse.
	xmlUiWidgetLink := self linkXmlUiWidget asDictionary reverse.
]

{ #category : #adding }
BLWebModelJava >> addLinkXmlUiWidget [
	xmlUiWidgetLink := self linkXmlUiWidget asDictionary reverse
]

{ #category : #adding }
BLWebModelJava >> addListsToModel [
	model
		silentlyAddAll: (self model allBLWidgetExceptPage flatCollect: #attributes);
		silentlyAddAll: (self model allBLWidgetExceptPage collect: #position thenReject: #isNil);
		silentlyAddAll: (self model allBLWidgetExceptPage collect: #size thenReject: #isNil);
		silentlyAddAll:
			((self model allBLWidgetExceptPage
				select: [ :a | (a isKindOf: BLUIContainer) and: [ a layout isNotNil ] ])
				flatCollect: [ :a | 
					{a layout.
					a layout cell.
					(a layout cell collect: #attributes)} ]) flattened;
		silentlyAddAll:
			((self model allBLPage flatCollect: #businessPage)
				select: [ :metier | metier name = 'autoGenerated' ])
	"Adding autoGeneratedPageMetier"
]

{ #category : #adding }
BLWebModelJava >> addOnClickAttribute [
	(((self sourceModel allClasses select: [ :c | 'ClickHandler' match: c name ]) at: 1)
		subclassHierarchy select: [ :class | self isElementFromApplication: class ])
		do: [ :class | 
			(class allUsages collect: #receiver)
				do: [ :receiver | 
					(self widgetInVariable: receiver)
						ifNotNil: [ :found |
							found createAttributeFrom: class
								 ] ] ]
]

{ #category : #adding }
BLWebModelJava >> addPPPToWidget [
	(self model allBLWidgetExceptPage select: [ :a | a widgetContainer isNil and: [ a cellOwner isNil ] ])
		do: [ :widget | 
			| founds |
			founds := self widgetOwnerCase1: widget source from.
			founds ifNotNil: [ founds do: [ :found | found addWidget: widget ] ] ]
]

{ #category : #adding }
BLWebModelJava >> addParentTo: widget withHandlerForUsages: responsabilityHandlerForUsages [
	^ widget affectedActions
		ifNotNil: [ | usages |
			usages := {widget affectedActions allUsages.widget affectedActions allUsages collect: [ :el | el allContainers ]} flattened
				reject: [ :el | (el receiver isNotNil and: [ (el receiver name includesSubstring: 'content') ]) or: [ (el signature prefixMatchesRegex: 'setWidget\(.*|add\(.*') not ] ].
			responsabilityHandlerForUsages
				handleAddLinkedFromVariable: usages asOrderedCollection 
				to: widget
				withXmlui: xmlUiWidgetLink
				andImporter: self ]
		ifNil: [ | containerInvocation |
			containerInvocation := widget source container.
			[ containerInvocation isNotNil ]
				whileTrue: [ | found |
					found := self widgetInVariable: containerInvocation receiver.
					found
						ifNotNil: [ found addWidget: widget withInvocationOfAdd: containerInvocation.
							containerInvocation := nil ]
						ifNil: [ containerInvocation := containerInvocation container ] ] ]
]

{ #category : #private }
BLWebModelJava >> addTo: aSourcedCollection from: anotherSourcedCollection in: theSelectorOfTheCollection [
	aSourcedCollection
		do: [ :source1 | 
			anotherSourcedCollection
				do: [ :source2 | (theSelectorOfTheCollection value: source1 ) add: source2 ] ]
]

{ #category : #adding }
BLWebModelJava >> addWidgetAttributes [
	(self model allBLWidgetExceptPage select: [ :widget | widget variable isNotNil ])
		do: [ :widget | 
			widget variable receivingInvocations
				do: [ :invoc | 
					(invoc signature = 'getFlexCellFormatter()' and: [ invoc previous isNotNil ])
						ifTrue: [ self factory createAttributeFromInvocation: invoc previous for: widget ]
						ifFalse: [ self factory createAttributeFromInvocation: invoc for: widget ] ] ]
		displayingProgress:
			[ :widget | 
			'compute attribute of '
				,
					widget
						asString ]
		every: 1000
]

{ #category : #adding }
BLWebModelJava >> addWidgetDefaultAttributes [
	self
		model allBLWidgetExceptPage
		do:
			#addDefaultAttribute
		displayingProgress: [ :widget | 'DefaultAttribute for ' , widget asString ]
		every: 1000
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> appNamespace [
	^ 'fr::bl::client::grh::*'
]

{ #category : #accessing }
BLWebModelJava >> applicationSource [
	"name of the directory with the GWT application"
	^  'BLCoreIncubatorGwt'
]

{ #category : #adding }
BLWebModelJava >> computeAllConstructorsLink [
	^ (self sourceModel constructors
		collect: [ :method | 
			| got |
			got := (method queryAll: #in) atScope: FAMIXClass.
			got
				ifNotEmpty: [ got collect: [ :p | Association new key: p value: method parentType ] ] ])
		flatten
]

{ #category : #accessing }
BLWebModelJava >> createFactory [
	factory := BLWidgetFactoryAngular new model: model; importer: self; yourself
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generateBLActionAppel [
	self model silentlyAddAll: (self linkFromWidgetActionAppel
		collect: [ :el | 
			| action |
			action := BLActionAppel new.
			el key addAction: action.
			el value ifNil: [  ] ifNotNil: [ action call: el value ].
			action ])
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generatePageMetier [
	sourceModel allModelClasses
		select: [ :e | 
			(e superclassHierarchy contains: [ :a | a name = 'IPageMetier' ])
				and: [ ('*XMLUi' match: e name) not ] ]
		thenCollect: [ :aPageMetier| self factory createBusinessPageFromFAMIXClass: aPageMetier ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generatePhase [
	xml
		nodesDo: [ :aXmlNode | 
			(aXmlNode isElement and: [ aXmlNode name localName = 'phase' ])
				ifTrue: [ self factory createPageFromXMLElement: aXmlNode ] ].
]

{ #category : #accessing }
BLWebModelJava >> generateService [
	| interfaceService |
	interfaceService := self sourceModel allTypes
		select: [ :e | (e superclassHierarchy anySatisfy: [ :a | a name = 'RemoteService' ]) and: e isInterface ].
	interfaceService addAll: ((interfaceService flatCollect: [ :class | class classes flatCollect: #attributes ]) collect: #declaredType).
	interfaceService do: [ :aServiceClass | self factory createServiceFromServiceClass: aServiceClass ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generateServiceAction [
	self model allBLService
		do: [ :e | 
			self model silentlyAddAll: (e addAllActions: (self getListOfServiceActionForServiceClass: e source)) ]
		displayingProgress: [ :e | 'compute ' , e asString ]
		every: 1000
	"self listOfServiceAction 
		addAll:
			((self listOfService
				collect: [ :service | service addAllActions: (self getListOfServiceActionForServiceClass: service source) ])
				collect: #actions) flattened"
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> generateWidget [
	self model silentlyAddAll: ((((self widgetConstructorsInvocation , self widgetAnonymousSubclasses , self widgetFactoryInvocation) asSet asOrderedCollection
		reject: [ :invocationOrClass | (self widgetNamespace match: invocationOrClass from mooseName) or: [ '*noname#super*' match: invocationOrClass asString ] ]
		thenCollect: [ :invocation | 
			| blWidget |
			blWidget := BLWidget newFor: invocation.
			blWidget affectedActions: (self searchAffectationForInvocationOrAnonymousClass: invocation).
			blWidget ]) groupedBy: #affectedActions) associationsDo: [ :assoc | assoc key ifNotNil: [ 2 to: assoc value size do: [ :i | assoc value removeIndex: i ] ] ]) flattened
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getAsyncClassFrom: aServiceClass. [
	^ (aServiceClass types asOrderedCollection 
		at: 1	ifAbsent: [ ^ {} ]) attributes
				collect: #declaredType
				thenSelect: [ :class | aServiceClass name , '*' match: class name ] 
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getClassNamed: aClassName [
	^ (self sourceModel allModelClasses select: [ :a | a mooseName = aClassName ]) at: 1
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getFromSource: listofSourcedElement forClass: aClass [
	^ (xmlUiLink at: aClass ifAbsent: [ ^ (listofSourcedElement select: [ :a | a source = aClass ]) ifEmpty: [ ^ nil ] ifNotEmpty: [ :a | {(a at: 1)} ] ])
		collect: [ :class | (listofSourcedElement select: [ :a | a source = class ]) ifEmpty: [ ^ nil ] ifNotEmpty: [ :a | a at: 1 ] ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getListOfServiceActionForServiceClass: aServiceClass [
	"Looking for class with `aServiceClass name ', Async'` 
	
	Currently disable because we don't know why we should want NOT async method... and all the method are the same.
	So we can say that all the non async method are also all the async method (with an arg less)
	Please consider this method return all the async method"

	| listOfSubAsyncClass |
	listOfSubAsyncClass := {} "self getAsyncClassFrom: aServiceClass".
	^ (listOfSubAsyncClass flatCollect: #methods) , aServiceClass methods reject: [ :method | method sourceAnchor sourceText isEmpty "reject method from src/target/... In source"]
		thenCollect: [ :method | BLServiceAction newFor: method ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getPageMetierFromClass: aClass [
	^ self getFromSource: self model allBLPageMetier forClass: aClass
]

{ #category : #private }
BLWebModelJava >> getPhaseCallInvocations [
	^ (((self sourceModel allClasses
		select:
			[ :a | '*ConstantsPhase' match: a mooseName ])
		at: 1) methods collect: #incomingInvocations) flatten
]

{ #category : #private }
BLWebModelJava >> getPhaseClassFrom: realClassName [
	realClassName ifNil: [ ^self ].
	^ (self sourceModel allClasses select: [ :e | realClassName = e mooseName ]) at: 1
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> getPhaseFromClass: aClass [
	^ self getFromSource: self model allBLPage forClass: aClass
]

{ #category : #private }
BLWebModelJava >> getPhaseNamed: aCodePhase [
	^ (self model allBLPage select: [ :e | e codePhase = aCodePhase ])
		ifEmpty: [ ^ nil ]
		ifNotEmpty: [ :a | a at: 1 ]
]

{ #category : #accessing }
BLWebModelJava >> gwtWidgetNamespace [
	^ 'com::google::gwt::user::client::ui*'
]

{ #category : #api }
BLWebModelJava >> import [
	'prepare generatePhase'
		displayProgressFrom: 0
		to: 18
		during: [ :bar | 
			bar current: 1.
			bar label: 1 printString , '/' , 18 printString , ' generatePhase'.
			self generatePhase.
			bar current: 2.
			bar label: 2 printString , '/' , 18 printString , ' generatePageMetier'.
			self generatePageMetier.
			bar current: 3.
			bar label: 3 printString , '/' , 18 printString , ' addLinkXmlUi'.
			self addLinkXmlUi.
			bar current: 4.
			bar label: 4 printString , '/' , 18 printString , ' generatePhase'.
			self addLinkXmlUiWidget.
			bar current: 5.
			bar label: 5 printString , '/' , 18 printString , ' addLinkForAbstractTabPhase'.
			self addLinkForAbstractTabPhase.
			bar current: 6.
			bar label: 6 printString , '/' , 18 printString , ' addLinkPhaseToPageMetier'.
			self addLinkPhaseToPageMetier.
			bar current: 7.
			bar label: 7 printString , '/' , 18 printString , ' addLinkPageMetierToPageMetier'.
			self addLinkPageMetierToPageMetier.
			bar current: 8.
			bar label: 8 printString , '/' , 18 printString , ' generateWidget'.
			self generateWidget.
			bar current: 9.
			bar label: 9 printString , '/' , 18 printString , ' addLinkBetweenWidgets'.
			"keep this order for the widget adding. The second one depends on the first one.... Maybe i should create one method 'generate widgetlink'"
			self addLinkBetweenWidgets.
			bar current: 10.
			bar label: 10 printString , '/' , 18 printString , ' addPPPToWidget'.
			self addPPPToWidget.
			bar current: 11.
			bar label: 11 printString , '/' , 18 printString , ' generateBLActionAppel'.
			self generateBLActionAppel.
			bar current: 12.
			bar label: 12 printString , '/' , 18 printString , ' generateService'.
			self generateService.
			bar current: 13.
			bar label: 13 printString , '/' , 18 printString , ' generateServiceAction'.
			self generateServiceAction.
			bar current: 14.
			bar label: 14 printString , '/' , 18 printString , ' addWidgetAttributes'.
			"this last two should stay at the end"
			self addWidgetAttributes.
			bar current: 15.
			bar label: 15 printString , '/' , 18 printString , ' addOnClickAttribute'.
			self addOnClickAttribute.
			bar current: 16.
			bar label: 16 printString , '/' , 18 printString , ' addWidgetDefaultAttributes'.
			self addWidgetDefaultAttributes.
			bar current: 17.
			bar label: 17 printString , '/' , 18 printString , ' addListsToModel'.
			self addListsToModel.
			bar current: 18.
			bar label: 18 printString , '/' , 18 printString , ' addLinkBetweenServiceAndAttribute'.
			self addLinkBetweenServiceAndAttribute ]
]

{ #category : #accessing }
BLWebModelJava >> isElementFromApplication: e [
	^ e sourceAnchor isNotNil and: [('*' , self applicationSource , '*' match: e sourceAnchor fileName)]
]

{ #category : #accessing }
BLWebModelJava >> isWidgetFromApplication: e [
	^ (self isElementFromApplication: e)
		and: [ (({self model allBLPage.
			self model allBLPageMetier} flatten collect: #source) includes: e) not ]
]

{ #category : #private }
BLWebModelJava >> linkForAbstractTabPhase [
	^ (self modelPhases 
		select: [ :a | 
			(a withSuperclassHierarchy collect: #name)
				anySatisfy: [ :name | 'AbstractTabPhaseController' = name ] ]
		thenCollect: [ :class | 
			class withSuperclassHierarchy
				collect: [ :c | 
					(c outgoingInvocations
						reject: [ :invoc | invoc receiver ifNotNil: [ :el | el name = #super ] ifNil: [ false ] ]
						thenCollect: [ :invoc | invoc candidates at: 1 ])
						select: [ :e | e isConstructor and: [ self modelPageMetier includes: e parentType ] ]
						thenCollect: [ :e | class -> e parentType ] ] ]) flattened
]

{ #category : #private }
BLWebModelJava >> linkFromWidgetActionAppel [
	" Miss 7
	4 for dispatch -> ignore
	3 for carousel"
	^ self getPhaseCallInvocations
		collect: [ :el | 
			| link |
			link := self linkFromWidgetActionAppelCase1: el.
			link ifNil: [ link := self linkFromWidgetActionAppelCase2: el ].
			link ]
		thenSelect: #isNotNil
]

{ #category : #private }
BLWebModelJava >> linkFromWidgetActionAppelCase1: anInvocation [
	"Return the found association
	case 1 and 4
	new Widget ( new blabla ( new bleble ( CP)))"

	| found elContainer |
	elContainer := anInvocation container.
	elContainer ifNil: [ ^ nil ].
	" case 1 "
	found := self searchWidgetFromConstructorInvocation: elContainer.
	found
		ifNotNil: [ ^ Association new key: found value: (self searchCalledPhaseFromInvocation: anInvocation) ]
		ifNil: [ ^ self linkFromWidgetActionAppelCase1: elContainer ]
]

{ #category : #private }
BLWebModelJava >> linkFromWidgetActionAppelCase2: anInvocation [
	"Return the found association
	case 2
	var i = new Widget ()
	i.addHandler..(BlBl)"
 
	anInvocation from parentType isHandlerClass
		ifFalse: [ ^ nil ].
	(self widgetInVariable:
			((anInvocation from parentType container outgoingInvocations
				select: [ :invoc | invoc sourceAnchor isNotNil and: [ 
					invoc sourceAnchor startPos < anInvocation sourceAnchor startPos
						and: [ invoc sourceAnchor endPos > anInvocation sourceAnchor endPos ] ] ]) at: 1 ifAbsent: [ ^ nil ])
				receiver)
		ifNotNil: [ :widgetContainer | 
			^ Association new
				key: widgetContainer
				value: (self searchCalledPhaseFromInvocation: anInvocation) ]
		ifNil:  [ ^ nil ]
]

{ #category : #private }
BLWebModelJava >> linkPageMetierToPageMetier [
	^ ((self model allBLPageMetier collect: #source) , xmlUiLink keys
		flatCollect: [ :pageMetier | 
			pageMetier incomingInstanciations
				reject: [ :invoc | invoc signature matchesRegex: '.*this\(.*|.*super\(.*' ]
				thenCollect: [ :invoc | 
					((self getPageMetierFromClass: (invoc to at: 1) parentType) at: 1)
						affectedActions: ((self searchAffectationForInvocationOrAnonymousClass: invoc) ifNil: [invoc]).
					(self getPageMetierFromClass: invoc from parentType)
						-> (self getPageMetierFromClass: (invoc to at: 1) parentType) ] ])
		select: [ :assoc | assoc key isNotNil ]
]

{ #category : #private }
BLWebModelJava >> linkXmlUiPhaseAndPageMetier [
	^ {self modelPhases  , self modelPageMetier} flatten
		select: [ :a | '*XMLUi' match: a superclass mooseName ]
		thenCollect: [ :a | Association new key: a  value: a superclass]
]

{ #category : #adding }
BLWebModelJava >> linkXmlUiWidget [
	^ {self modelWidget} flatten
		select: [ :a | '*XMLUi' match: a superclass mooseName ]
		thenCollect: [ :a | Association new key: a  value: a superclass]
]

{ #category : #accessing }
BLWebModelJava >> modelPageMetier [
	^ self model allBLPageMetier collect: #source
]

{ #category : #private }
BLWebModelJava >> modelPhases [
	"support the C/S Phase (see application RH)"
	^ self model allBLPage collect: #source thenReject: #isNil 
]

{ #category : #accessing }
BLWebModelJava >> modelWidget [
	^ modelWidgetCache
		ifNil: [ modelWidgetCache := self sourceModel allClasses
				select: [ :e | 
					(e superclassHierarchy anySatisfy: [ :a | a name = 'Widget' ])
						and: [ (self widgetNamespace match: e container mooseName)  or: [ (self gwtWidgetNamespace match: e container mooseName )
								or: [ self isWidgetFromApplication: e ] ] ] ] ]
]

{ #category : #private }
BLWebModelJava >> modelWidgetInstances [
	^ self model allBLWidget collect: #source
]

{ #category : #api }
BLWebModelJava >> postImport [
	"self model allBLActionsAttribute do: [ :actionAttribute | actionAttribute convertOldClass ]."
	self model allBLWidget do: [ :widget | widget postImport ].
	(self model allBLWidget select: [ :widget | (widget isKindOf: BLUIContainer) and: [widget layout isNotNil] ]) do: [ :widget | widget layout postImport ].
	self model allBLPage do: [ :phase | phase postImport ]
]

{ #category : #api }
BLWebModelJava >> preImport [
	super preImport
	"BLActionAttribute moulinetteStrategy: BLMoulinetteFASTStrategy new."
]

{ #category : #private }
BLWebModelJava >> searchAffectationForInvocationOrAnonymousClass: anInvocationOrAnonymousClass [
	"The mooseVariable if there is an affactation
	else nil
	
	1. We look for a local variable
	2. We look for a class variable 
		2.1 Because we don't have enought information with famix. We've supposed that the affectation is not to far from the access of the variable. So we've write 5 'space'. But it's not sure
	3. We look in declaration in the class
	"

	^ anInvocationOrAnonymousClass affectation
]

{ #category : #private }
BLWebModelJava >> searchCalledPhase: aSignature [
	^ (self getPhaseNamed: (aSignature replaceAllRegex: '\(\)' with: '')) ifNil: [^nil]
]

{ #category : #private }
BLWebModelJava >> searchCalledPhaseFromInvocation: invoc [
	^ self searchCalledPhase:  (invoc to at: 1) signature
]

{ #category : #private }
BLWebModelJava >> searchWidgetFromConstructorInvocation: anInvocation [
	^ (self model allBLWidget select: [ :widget | widget source = anInvocation ]) at: 1 ifAbsent: [ ^ nil ]
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetAnonymousSubclasses [
	^ ((self modelWidget flatCollect: [ :widget | widget subclassHierarchy ]) select: #isAnonymousClass) asOrderedCollection 
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetConstructorsInvocation [
	"Get the constructor and try to determine the stub constructor"

	^ (self modelWidget
		collect: [ :widget | 
			widget methods
				select: [ :method | 
					method isConstructor
						or: [ (method name copyReplaceAll: '.' with: '::') asSymbol = method parentType mooseName  ] ]
				thenCollect: #incomingInvocations ]) flattened
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetFactoryInvocation [
	^ (((self sourceModel allModelClasses select: [ :a | a name = 'FactoryBLLabel' or: [ a name = 'ComponentUtils' ] ])
		flatCollect: #methods)
		select: [ :m | m name = 'create' or: [ m name beginsWith: 'getLibelleItem' ] ]
		thenCollect: #incomingInvocations) flatten
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetInVariable: aVariable [
	aVariable ifNil: [ ^ nil ].
	^ (self model allBLWidget select: [ :el | el variable = aVariable ]) at: 1 ifAbsent: nil
]

{ #category : #accessing }
BLWebModelJava >> widgetNamespace [
	^ 'fr::bl::client::core::refui*'
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetOwnerCase1: invocation [
	| found |
	(invocation isNil or: [ invocation isNamespace ])
		ifTrue: [ ^ nil ].
	invocation isClass
		ifFalse: [ ^ self widgetOwnerCase1: invocation belongsTo ]
		ifTrue: [ found := self getPhaseFromClass: invocation.
			found
				ifNotNil: [ ^ found ]
				ifNil: [ found := self getPageMetierFromClass: invocation.
					found ifNotNil: [ ^ found ].
					invocation incomingReferences ifNotEmpty: [ :references | ^ self widgetOwnerCase1: (references at: 1) from belongsTo maxLevel: 15 level: 0 ] ] ].
	^ self widgetOwnerCase1: invocation belongsTo
]

{ #category : #'as yet unclassified' }
BLWebModelJava >> widgetOwnerCase1: invocation maxLevel: maxLevel level: level [
	| found |
	level = maxLevel
		ifTrue: [ ^ nil ].
	(invocation isNil or: [ invocation isNamespace ])
		ifTrue: [ ^ nil ].
	invocation isClass
		ifFalse: [ ^ self widgetOwnerCase1: invocation maxLevel: maxLevel level: level + 1 ]
		ifTrue: [ found := self getPhaseFromClass: invocation.
			found
				ifNotNil: [ ^ found ]
				ifNil: [ found := self getPageMetierFromClass: invocation.
					found ifNotNil: [ ^ found ].
					invocation incomingReferences ifNotEmpty: [ :references | ^ self widgetOwnerCase1: (references at: 1) from belongsTo maxLevel: maxLevel level: level + 1 ] ] ].
	^ self widgetOwnerCase1: invocation maxLevel: maxLevel level: level + 1 
]

{ #category : #accessing }
BLWebModelJava >> xml [
	^ xml
]

{ #category : #accessing }
BLWebModelJava >> xml: anObject [
	xml := anObject
]
